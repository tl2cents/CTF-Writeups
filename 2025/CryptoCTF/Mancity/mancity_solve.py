
from sage.all import PolynomialRing, Zmod
from Crypto.Util.number import long_to_bytes
n = 147170819334030469053514652921356515888015711942553338463409772437981228515273287953989706666936875524451626901247038180594875568558137526484665015890594045767912340169965961750130156341999306808017498374501001042628249176543370525803456692022546235595791111819909503496986338431136130272043196908119165239297
c = 77151713996168344370880352082934801122524956107256445231326053049976568087412199358725058612262271922128984783428798480191211811217854076875727477848490840660333035334309193217618178091153472265093622822195960145852562781183839474868269109313543427082414220136748700364027714272845969723750108397300867408537

qlsb = int(256 * '1', 2)
plsb = pow(qlsb, -1, 2**256) * n % 2**256
assert plsb * qlsb % 2**256 == n % 2**256

plsb_bits = bin(plsb)[2:].zfill(256)
qbits = ""
for i in range(0, 256, 2):
    if plsb_bits[i:i+2] == '01':
        qbits += '0'
    elif plsb_bits[i:i+2] == '11':
        qbits += '1'
    else:
        raise ValueError("Unexpected bits in plsb")

qleak = int(qbits, 2) * 2**256 + qlsb
print(f"q_leak: {qleak}")        
pr = PolynomialRing(Zmod(n), 'x')
x = pr.gen()
f = qleak  + x * 2**(256 + 128)
root = f.monic().small_roots(X = 2**(128), beta = 0.499, epsilon = 0.05)
if root:
    qh = root[0]
    q = int(qh) * 2**(256 +128) + qleak
    p = n // q
    assert p * q == n
    d = pow(1234567891, -1, (p-1)*(q-1))
    m = pow(c, d, n)
    flag = long_to_bytes(m)
    print(f"Flag: {flag}")